### 1.1 程序设计的基本元素

#### excercise 1.1

以下结果是在Ubuntu 20.04 mit-scheme解释器中得到的结果：

```scheme
1]=> 10
Value: 10


1]=> (+ 5 3 4)
Value: 12


1]=> (- 9 1)
Value: 8


1]=> (/ 6 2)
Value: 3


1]=> (define a 3)
Value: a


1]=> (define b (+ a 1))
Value: b


1]=> (+ a b (* a b))
Value: 19


1]=> (= a b)
Value: #f


1]=> (if (and (> b a) (< b (* a b)))
         b
         a)
Value: 4


1]=> (cond ((= a 4) 6)
           ((= b 4) (+ 6 7 a))
           (else 25))
Value: 16


1]=> (+ 2 (if (> b a) b a))
Value: 6


1]=> (* (cond ((> a b) a)
              ((< a b) b)
              (else -1))
        (+ a 1))
Value: 16
```

#### exercise 1.2

前缀形式为：

```scheme
(/ (+ 5
      4
      (- 2
         (- 3
            (+ 6
               (/ 4 5)))))
   (* 3
      (- 6 2)
      (- 2 7)))
```

#### exercise 1.3

```scheme
(define (max a b)
  (cond ((< a b) b)
        (else a)))

(define (sum-of-top2 a b c)
 (
  	max (+ a b) (max (+ a c) (+ b c))
 )
)
```

#### exercise 1.4

```scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

上述过程将一个复合表达式``(if (> b 0) + -)``应用于参数``a,b``, 当``b``大于零的时候，返回值为``+``运算符，小于0时返回``-``运算符，然后将这两个运算符作用于参数``a,b``之上。最后的结果就是``a+|b|``

#### exercies1.5

````scheme
(define (p) (p))
(define (test x y)
  (if (= x 0)
        0
        y))
(test 0 (p))
````

如果采用应用序求值，那么会先进行参数的计算，对``(p)``的计算将导致解释器陷入无限循环。因为对过程``p``的调用始终会返回自身。而对``p``求值又会继续返回自身，从而陷入无限循环。如果采用正则序求值，则只会在需要的时候进行求值，这样调用``test``的时候，由于第一个参数为0，直接得到值0，不会求第二个参数，也就不会陷入无限循环。

综上，如果采用应用序求值，则会陷入无限循环；采用正则序求值，则不会。