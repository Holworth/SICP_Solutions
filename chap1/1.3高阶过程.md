### 1.3高阶过程

#### exercise1.29

整个代码如下所示：

```scheme
(define (Sipson-integral f a b n)
 (define h (/ (- b a) n))

 (define (cof k)
  (cond ((or (= k 0) (= k n)) 1)
         ((even? k) 2)
         (else 4)))

 (define (term n)
  (* (cof n)
     (f (+ a (* n h)))))
 
 (define (inc n) (+ n 1))
 
 (* (sum term 0 inc n)
    (/ h 3.0)))
```

上述代码的执行情况如下：

```bash
1 ]=> (Sipson-integral cube 0 1 100)
;Value: .25

1 ]=> (Sipson-integral cube 0 1 1000)
;Value: .25
```

能直接得到0.25的正确值而没有任何偏差是我所没有预料到的。

#### exercise1.30

从书中给出的提示不难看出。在``iter``过程中，使用一个参数``a``来表示当前的下标，使用一个结果``result``来表示当前已经完成计算的部分和。完整的代码如下所示：

```scheme
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter a 0))
```

将该过程用于``integral``的计算并与之前的计算结果对比就能发现结果是正确的。

#### exercise1.31

##### (a)

定义``product``的方法和定义``sum``的方法类似，只是将``sum``中的加操作替换为乘法操作。代码如下：

```scheme
(define (product term a next b)
    (if (> a b)
        1
        (* (term a) (product term (next a) next b))))

(define (factorial n)
    (define (inc n) (+ n 1))
    (define (id n) n)
    (product id 1 inc n))
```

而``factorial``， 意为阶乘，实际上也只是从1到n的范围内求所有数的乘积。

计算``pi``的时候，我们需要分别对分子和分母计算部分和然后再相除。计算分子时，通过观察我们可以发现，偶数下标的值就是将下标加2，奇数下标就是加一。对于分母，则恰好相反。代码如下所示：

```scheme
(define (pi-sum n)

    (define (inc n) (+ n 1))

    (define (numer n)
        (if (even? n)
            (+ n 2)
            (+ n 1)))

    (define (denom n)
        (if (even? n)
            (+ n 1)
            (+ n 2)))
    (* 4.0
       (/ (product numer 1 inc n)
          (product denom 1 inc n))))
```

最后将结果乘以4.0直接得到``pi``的值。计算的结果如下：

```bash
1 ]=> (pi-sum 100)
;Value: 3.1570301764551676

1 ]=> (pi-sum 1000)
;Value: 3.1431607055322663

1 ]=> (pi-sum 10000)
;Value: 3.1417497057380523
```

随着n的增加，计算结果越来越精确，但速度也越来越慢。

##### (b)

将上述递归计算过程改为迭代计算过程的方法和``1-30``中的方法一样，每次都使用一个参数作为计算得到的部分和进行传递。代码如下：

```scheme
(define (product-iter term a next b)
    (define (iter a result)
        (if (> a b)
            result
            (iter (next a) (* (term a) result))))
    (iter a 1))
```

#### exercise1.32

```scheme
(define (accumulate combiner null-value term a next b)
    (if (> a b)
        null-value
        (combiner (term a)
                  (accumulate combiner null-value term (next a) next b))))

(define (sum term a next b)
    (define (add a b) (+ a b))
    (accumulate add 0 term a next b))

(define (product term a next b)
    (define (mul a b) (* a b))
    (accumulate mul 1 term a next b))
```

改写为迭代的做法与前面几题的做法相同。

```scheme
(define (accumulate-iter combiner null-value term a next b)
    (define (iter a result)
        (if (> a b)
            result
            (iter (next a) (combiner (term a) result))))
    (iter 1 null-value))
```

#### exercise1.33

本题需要我们实现有条件地combine两个结果。所以通过参数中给出的谓词``filtered``实现另一个局部的``filtered-combiner``，其逻辑是当前新加入的数如果满足条件就调用``combiner``将其组合在一起，否则就返回原先的数。然后调用``filtered-combiner``用于该过程：

```scheme
(define (filtered-accumulate combiner null-value filter? term a next b)
    (define (filtered-combiner a b)
        (if (filter? a)
            (combiner a b)
            b))
    (if (> a b)
        null-value
        (filtered-combiner (term a)
                           (filtered-accumulate combiner null-value filter? term (next a) next b))))
```

在第一部分求素数之和时，如果采用书上33页的程序检测素数会导致将1也判断为素数，这是不符合数学定义的，所以在``prime?``谓词中要单独加入对1的判断逻辑。如下：

```scheme
(define (prime? n)
    (if( = n 1)
       false
       (= (smallest-divisor n) n)))
```

其余的完整代码可参考``code``文件夹下的``33-filtered-accumulate.scm``文件。